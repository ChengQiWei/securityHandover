/*
 * Copyright (C) 2007 IAIK, Graz University of Technology
 * authors: Thomas Winkler
 */

package iaik.tc.tss.test.tsp.java.identity.split;


import iaik.tc.tss.api.constants.tpm.TcTpmConstants;
import iaik.tc.tss.api.constants.tpm.TcTpmOrdinals;
import iaik.tc.tss.api.constants.tsp.TcTssConstants;
import iaik.tc.tss.api.exceptions.common.TcTssException;
import iaik.tc.tss.api.structs.common.TcBlobData;
import iaik.tc.tss.api.structs.tpm.TcTpmAsymCaContents;
import iaik.tc.tss.api.structs.tpm.TcTpmChosenIdHash;
import iaik.tc.tss.api.structs.tpm.TcTpmDigest;
import iaik.tc.tss.api.structs.tpm.TcTpmIdentityContents;
import iaik.tc.tss.api.structs.tpm.TcTpmIdentityProof;
import iaik.tc.tss.api.structs.tpm.TcTpmIdentityReq;
import iaik.tc.tss.api.structs.tpm.TcTpmKeyParms;
import iaik.tc.tss.api.structs.tpm.TcTpmPubkey;
import iaik.tc.tss.api.structs.tpm.TcTpmStructVer;
import iaik.tc.tss.api.structs.tpm.TcTpmSymCaAttestation;
import iaik.tc.tss.api.structs.tpm.TcTpmSymmetricKey;
import iaik.tc.tss.api.structs.tpm.TcTpmSymmetricKeyParms;
import iaik.tc.tss.api.tspi.TcIContext;
import iaik.tc.tss.api.tspi.TcIHash;
import iaik.tc.tss.api.tspi.TcIRsaKey;
import iaik.tc.tss.api.tspi.TcITpm;
import iaik.tc.tss.api.tspi.TcTssAbstractFactory;
import iaik.tc.tss.impl.csp.TcCrypto;
import iaik.tc.tss.test.tsp.java.TestDefines;

import java.security.GeneralSecurityException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.CertificateException;
import java.security.interfaces.RSAPublicKey;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class PrivacyCa {

	/**
	 * The RSA key pair of the Privacy CA.
	 */
	protected PrivateKey privKeyPrivacyCa_ = null;

	/**
	 * The public key of the Privacy CA.
	 */
	private PublicKey pubKeyPrivacyCa_ = null;

	/**
	 * TSS context.
	 */
	TcIContext context_;


	/**
	 * Constructor.
	 */
	public PrivacyCa(TcTssAbstractFactory tssFactory) throws TcTssException, NoSuchAlgorithmException
	{
		context_ = tssFactory.newContextObject();
		context_.connect();
		createCaKeypairs();
	}


	// ----------------------------------------------------------------------------------------------
	// Privacy CA methods for CA setup (i.e. create CA key pair)
	// ----------------------------------------------------------------------------------------------

	/*************************************************************************************************
	 * This method creates an RSA key pair that is used as the key pair of the Privacy CA.
	 *
	 * @return the public key of the CA. This key is required by the client for the CollateIdentity
	 *         request.
	 * @throws TcTssException
	 */
	protected void createCaKeypairs() throws NoSuchAlgorithmException
	{
		// note: The TPM specification defines the public exponent to be 2^16 + 1 = 65537
		// for RSA keys generated by the TPM. The key pair of the Privacy CA is not required to be
		// generated inside a TPM. Hence, a different public exponent might be used.
		// Note that the default public exponent used by Java defaults to the same value as used
		// by the TCG.con

		KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
		generator.initialize(Constants.CA_KEY_LENGTH);

		KeyPair kpairPrivacyCa = generator.generateKeyPair();
		privKeyPrivacyCa_ = kpairPrivacyCa.getPrivate();
		pubKeyPrivacyCa_ = kpairPrivacyCa.getPublic();
	}


	/*************************************************************************************************
	 * This method extracts the public Privacy CA key and wraps it into a TSS key object. This TSS key
	 * object is used by the client as part of the CollateIdentityRequest.
	 */
	public TcTpmPubkey getPrivacyCaPubKey() throws TcTssException
	{
		return TcCrypto.pubJavaToTpmKey((RSAPublicKey)pubKeyPrivacyCa_);
	}


	// ----------------------------------------------------------------------------------------------
	// Privacy CA methods for AIK cycle
	// ----------------------------------------------------------------------------------------------

	/*************************************************************************************************
	 * This is the main method at the CA side which calls several sub methods. These sub methods
	 * decrypt the identity request blob from the client, verify the identity proof and the client
	 * credentials, issue an AIK credential and finally generate the response for the client.
	 *
	 * @param collateIdentityReqBlob The raw CollateIdentityReq data blob
	 * @return symmetrically and asymmetrically encrypted CA response blobs
	 *
	 * @throws TcTssException
	 * @throws CertificateException This exception is thrown if the verification of the client
	 *           certificates failed.
	 * @throws GeneralSecurityException This exception is thrown if the decryption of the client blob
	 *           failed.
	 */
	protected Object[] mainRoutine(TcBlobData collateIdentityReqBlob)
		throws TcTssException, CertificateException, GeneralSecurityException
	{
		// step 1: decrypt and decode the collate identity request blob from the client

		TcTpmIdentityProof identityProof = decryptIdentityReqBlob(collateIdentityReqBlob);

		// step 2: verify the identity proof from the client

		verifyIdentityProof(identityProof);

		// step 3: verify the credentials (endorsement, platform, conformance) received from the client

		verifyCredentials(identityProof);

		// step 4: issue the AIK credential

		TcBlobData aikCredential = buildAikCredential(identityProof);

		// step 5: build response for the client

		Object[] response = buildResponse(identityProof, aikCredential);

		// step 6: return response to the caller

		return response;
	}


	/*************************************************************************************************
	 * This method takes the CollateIdentityReq blob from the client and decrypts the components: (1)
	 * The asymBlob containing the symmetric key encrypted with the CAs public RSA key. (2) The
	 * symBlob (containing an TPM_IDENTITY_PROOF instance) encrypted with the symmetric session key.
	 * Finally, the TPM_IDENTITY_PROOF instance is returned.
	 *
	 * @param collateIdentityReqBlob The raw CollateIdentityReq data blob.
	 * @return Instance of TPM_IDENTITY_PROOF contained in the CollateIdentityReq data blob.
	 *
	 * @throws TcTssException
	 * @throws GeneralSecurityException Indicates the decrypting the client blob failed.
	 */
	protected TcTpmIdentityProof decryptIdentityReqBlob(TcBlobData collateIdentityReqBlob)
		throws TcTssException, GeneralSecurityException
	{
		// step 1: decode the collate identity request blob
		TcTpmIdentityReq collateIdentityReq = new TcTpmIdentityReq(collateIdentityReqBlob);

		TcBlobData symBlobDecrypted = null;

		// step 2: decrypt the symmetric key (encrypted by the client with the public CA key)

		Cipher rsaDec = Cipher.getInstance("RSA/ECB/PKCS1Padding");
		rsaDec.init(Cipher.DECRYPT_MODE, privKeyPrivacyCa_);
		TcTpmSymmetricKey symmetricKey = new TcTpmSymmetricKey( //
				TcBlobData.newByteArray(rsaDec.doFinal(collateIdentityReq.getAsymBlob().asByteArray())));

		// step 3: decrypt the symmetrically encrypted data

		byte[] iv = null;
		byte[] symBlob = null;
		if (Constants.TROUSERS_COMPATIBILITY) {
			// for TrouSerS the IV for CBC mode is prepend to the encrypted data
			iv = collateIdentityReq.getSymBlob().getRange(0, (int) Constants.SYM_IV_LEN / 8);

			// the symmetrically encrypted data blob starts after the IV
			symBlob = collateIdentityReq.getSymBlob().getRange((int) Constants.SYM_IV_LEN / 8,
					collateIdentityReq.getSymBlob().getLength() - (int) Constants.SYM_IV_LEN / 8);

		} else {

			// jTSS is a 1.2 stack that supports the TPM_SYMMETRIC_KEY_PARAMS structure
			TcTpmSymmetricKeyParms symKeyParams = new TcTpmSymmetricKeyParms(collateIdentityReq
					.getSymAlgorithm().getParms());
			iv = symKeyParams.getIV().asByteArray();

			symBlob = collateIdentityReq.getSymBlob().asByteArray();

		}

		IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);

		Cipher aesDec = Cipher.getInstance(Constants.SYM_ALGO_JAVA + "/CBC/PKCS5Padding");
		SecretKeySpec skeySpec = new SecretKeySpec(symmetricKey.getData().asByteArray(),
				Constants.SYM_ALGO_JAVA);

		aesDec.init(Cipher.DECRYPT_MODE, skeySpec, ivParameterSpec);
		symBlobDecrypted = TcBlobData.newByteArray(aesDec.doFinal(symBlob));

		// the decrypted data is of type TPM_IDENTITY_PROOF
		TcTpmIdentityProof identityProof = new TcTpmIdentityProof(symBlobDecrypted);

		return identityProof;
	}


	/*************************************************************************************************
	 * This method verifies the identity proof that was generated at the client side as part of the
	 * CollateIdentityReq method call.
	 */
	protected void verifyIdentityProof(TcTpmIdentityProof identityProof) throws TcTssException
	{
		// step 1: The identity key label and the public key of the CA are concatenated.
		// Then the sha1 hash of this data blob is computed.
		// This TPM_CHOSENID_HASH is part of the TPM_IDENTITY_CONTENTS structure.

		// Note from the TPM Spec:
		// "The reason for including the hash of the public key of the Privacy CA inside
		// identity-binding signature is to prevent a rogue obtaining attestation from multiple Privacy
		// CAs. The identity-binding signature creation is an atomic operation performed at the same
		// time as the key pair creation, and therefore the TPM cannot be coerced into creating a
		// version of the identity-binding signature with the same keys but a different Privacy CA
		// public key.

		TcBlobData chosenIdHashData = (TcBlobData) identityProof.getLabelArea().clone();
		chosenIdHashData.append(getPrivacyCaPubKey().getEncoded());

		TcTpmChosenIdHash chosenIdHash = new TcTpmChosenIdHash(chosenIdHashData.sha1());

		// step 2: create an TPM_IDENTITY_CONTENTS instance

		TcTpmIdentityContents identityContents = new TcTpmIdentityContents();
		// Note on StructVer: The PrivacyCA can not know which version string was used by the client
		// TPM to create the request blob (can be the real TPM version as on (all?) 1.1b TPMs or
		// fixed to 1.1.0.0. The jTSS sets the version reported by the TPM_CAP_VERSION into the
		// identityProof structure (this is either the real version on 1.1b or 1.1.0.0 on 1.2).
		// By using this version field, the PrivacyCA has a good chance to correctly verify the
		// request generated in the client TPM.
		identityContents.setVer((TcTpmStructVer)identityProof.getVersion());
		identityContents.setOrdinal(TcTpmOrdinals.TPM_ORD_MakeIdentity);
		identityContents.setLabelPrivCADigest(chosenIdHash);
		identityContents.setIdentityPubKey(identityProof.getIdentityKey());

		TcBlobData identityContentsHash = identityContents.getEncoded().sha1();

		// step 3: verify the identity proof

		// step 3a: wrap AIK

		TcIRsaKey aikKey = context_.createRsaKeyObject(TcTssConstants.TSS_KEY_TYPE_IDENTITY
				| TcTssConstants.TSS_KEY_SIZE_2048 | TcTssConstants.TSS_KEY_VOLATILE
				| TcTssConstants.TSS_KEY_AUTHORIZATION | TcTssConstants.TSS_KEY_NOT_MIGRATABLE);

		aikKey.setAttribData(TcTssConstants.TSS_TSPATTRIB_KEY_BLOB,
				TcTssConstants.TSS_TSPATTRIB_KEYBLOB_PUBLIC_KEY, identityProof.getIdentityKey()
						.getEncoded());

		// Note:
		// identityContentsHash is the expected hash value as generated in step 1 and 2.
		// identityProof.
		// IdentityBinding (from identityProof.getIdentityBinding()) contains the signed hash
		// value that was generated on the client inside the TPM as part of the
		// CollateIdentityReq call. This hash value was signed using the private part
		// of the new AIK on the client. The verifySignature method takes this signed hash,
		// decrypts it with the public aikKey and compares it to the value provided in
		// identityContentsHash.

		// step 3b: actual verification

		TcIHash hash = context_.createHashObject(TcTssConstants.TSS_HASH_SHA1);
		hash.setHashValue(identityContentsHash);
		hash.verifySignature(identityProof.getIdentityBinding(), aikKey);
	}


	/*************************************************************************************************
	 * This method is designed to verify the credentials supplied by the client. Only if all
	 * credentials could be verified to meet the TCG specs and the policies of the Privacy CA, this
	 * method succeeds.
	 */
	protected void verifyCredentials(TcTpmIdentityProof identityProof) throws CertificateException
	{
		// step 1: verify conformance credential (identityProof.getConformanceCredential())
		// NOT IMPLEMENTED

		// step 2: verify platform credential (identityProof.getPlatformCredential())
		// NOT IMPLEMENTED

		// step 3: verify endorsement credential (identityProof.getEndorsementCredential())
		// NOT IMPLEMENTED
	}


	/*************************************************************************************************
	 * This method constructs the AIK credential.
	 */
	protected TcBlobData buildAikCredential(TcTpmIdentityProof identityProof)
		throws CertificateException
	{
		// NOT IMPLEMENTED: build and sign the AIK credential
		// The TCcert library available from http://trustedjava.sf.net can be used for that purpose.
		// The Java TPM Tools available at the same location provide an implementation of the createAIK
		// cycle that combines this AIK creation code with the certificate creation code of TCcert.

		return TcBlobData.newString("AikDummyCert");
	}


	/*************************************************************************************************
	 * This method builds the response the Privacy CA sends to the client. This response consists of
	 * two parts: (1) An asymmetrically encrypted part (encrypted with the public EK of the client's
	 * TPM). This part contains the symmetric session key and a hash of the new identity key. This
	 * hash is used by the client's TPM in the ActivateIdentity call to identify the key the AIK
	 * credential belongs to. (2) A symmetrically encrypted part that contains the new AIK credential.
	 */
	protected Object[] buildResponse(TcTpmIdentityProof identityProof, TcBlobData aikCredential)
		throws TcTssException
	{
		// step 1: create the symmetric CA blob (TPM_SYM_CA_ATTESTATION) containing the
		// AIK credential

		TcTpmSymmetricKeyParms symParams = new TcTpmSymmetricKeyParms();
		symParams.setKeyLength(Constants.SYM_KEY_LEN);
		symParams.setBlockSize(Constants.SYM_BLOCK_SIZE);
		symParams.setIV(TcCrypto.getRandom((int)(Constants.SYM_IV_LEN / 8)));

		TcTpmKeyParms symCaAttestationKeyParms = new TcTpmKeyParms();
		symCaAttestationKeyParms.setAlgorithmID(Constants.SYM_ALGO_TSS);
		// TPM level structures are filled with TPM level constants
		symCaAttestationKeyParms.setEncScheme((int) TcTpmConstants.TPM_ES_SYM_CBC_PKCS5PAD);
		symCaAttestationKeyParms.setSigScheme((int) TcTpmConstants.TPM_SS_NONE);
		symCaAttestationKeyParms.setParms(symParams.getEncoded());

		TcTpmSymCaAttestation symCaAttestation = new TcTpmSymCaAttestation();
		symCaAttestation.setAlgorithm(symCaAttestationKeyParms);
		symCaAttestation.setCredential(aikCredential);

		// step 2: generate a symmetric session key

		TcTpmSymmetricKey symCaKey = new TcTpmSymmetricKey();
		symCaKey.setAlgId(symCaAttestationKeyParms.getAlgorithmID());
		symCaKey.setEncScheme((int) symCaAttestationKeyParms.getEncScheme());
		if (Constants.SYM_ALGO == TcTssConstants.TSS_ALG_3DES) {
			symCaKey.setData(TcCrypto.create3DESkey());
		} else {
			symCaKey.setData(TcCrypto.createAESkey((int) Constants.SYM_KEY_LEN));
		}

		// step 3: symmetric encryption

		TcBlobData symBlobEncrypted = null;
		if (Constants.TROUSERS_COMPATIBILITY) {
			// as a 1.1 stack, TrouSerS does not have the TPM_SYMMETRIC_PARAMS struct
			symCaAttestationKeyParms.setParms(null);

			// as a 1.1 stack TrouSerS does not know about TPM_ES_SYM_CBC_PKCS5PAD;
			// CBC mode is used implicitly
			symCaAttestationKeyParms.setEncScheme((int) TcTpmConstants.TPM_ES_NONE);
			symCaKey.setEncScheme((int) TcTpmConstants.TPM_ES_NONE);

			// only encrypt the AIK credential with the symmetric key (as defined by the TSS spec)
			TcBlobData encryptedCredential = TcCrypto.encryptSymmetricCbcPkcs5Pad(Constants.SYM_ALGO_JAVA, symCaKey
					.getData(), symParams.getIV(), symCaAttestation.getCredential());

			// TrouSerS: prepend the IV to the symmetrically encrypted blob
			encryptedCredential.prepend(symParams.getIV());
			symCaAttestation.setCredential(encryptedCredential);
			symBlobEncrypted = symCaAttestation.getEncoded();

		} else {
			// only encrypt the AIK credential with the symmetric key (as defined by the TSS spec)
			TcBlobData encryptedCredential = TcCrypto.encryptSymmetricCbcPkcs5Pad(
					Constants.SYM_ALGO_JAVA, symCaKey.getData(), symParams.getIV(), symCaAttestation
							.getCredential());

			// set the encrypted AIK credential
			symCaAttestation.setCredential(encryptedCredential);

			symBlobEncrypted = symCaAttestation.getEncoded();
		}

		// step 4: Create an instance of TPM_ASYM_CA_CONTENS to hold the symmetric key.
		// This blob is later encrypted with the public endorsement key of the client.

		TcTpmDigest identityKeyHash = new TcTpmDigest();
		identityKeyHash.setDigest(identityProof.getIdentityKey().getEncoded().sha1());

		TcTpmAsymCaContents asymCaContents = new TcTpmAsymCaContents();
		asymCaContents.setSessionKey(symCaKey);
		asymCaContents.setIdDigest(identityKeyHash);

		// step 5: Encrypt the TPM_ASYM_CA_CONTENTS instance with the public EK of the client's TPM

		// NOTE: The real Privacy CA can not access the public endorsement key of the client this way
		// (the Privacy CA and the client typically will not be located on the same machine).
		// The key has to be extracted from the endorsement credential provided by the client.

		// get public EK
		TcITpm tpm = context_.getTpmObject();
		TestDefines.tpmPolicy.assignToObject(tpm);
		TcIRsaKey pubEK = tpm.getPubEndorsementKeyOwner();
		TcTpmPubkey tpmPubEk = new TcTpmPubkey(pubEK.getAttribData(
				TcTssConstants.TSS_TSPATTRIB_KEY_BLOB, TcTssConstants.TSS_TSPATTRIB_KEYBLOB_PUBLIC_KEY));

		// encrypt the asymCaContents
		TcBlobData asymCaContentsEncrypted = TcCrypto.pubEncryptRsaOaepSha1Mgf1(tpmPubEk,
				asymCaContents.getEncoded());

		// return the blob
		// symCaAttestation.credential holds the symmetrically encrypted AIK credential (the rest of the
		// structure is not encrypted).
		// asymCaContentsEncrypted holds symmetric session key (plus some key info) encrypted with the
		// public EK of the client.
		// return new Object[] { symCaAttestation.getEncoded(), asymCaContentsEncrypted };
		return new Object[] { symBlobEncrypted, asymCaContentsEncrypted };
	}
}
