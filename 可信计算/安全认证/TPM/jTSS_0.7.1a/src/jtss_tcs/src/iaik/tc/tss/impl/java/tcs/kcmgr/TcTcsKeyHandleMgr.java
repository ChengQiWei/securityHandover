/*
 * Copyright (C) 2007 IAIK, Graz University of Technology
 * authors: Thomas Winkler
 */

package iaik.tc.tss.impl.java.tcs.kcmgr;


import iaik.tc.tss.api.constants.tcs.TcTcsErrors;
import iaik.tc.tss.api.constants.tpm.TcTpmConstants;
import iaik.tc.tss.api.constants.tpm.TcTpmOrdinals;
import iaik.tc.tss.api.exceptions.common.TcTssException;
import iaik.tc.tss.api.exceptions.tcs.TcTcsException;
import iaik.tc.tss.api.exceptions.tcs.TcTddlException;
import iaik.tc.tss.api.exceptions.tcs.TcTpmException;
import iaik.tc.tss.api.structs.common.TcBasicTypeDecoder;
import iaik.tc.tss.api.structs.common.TcBlobData;
import iaik.tc.tss.api.structs.tpm.TcTpmKeyHandleList;
import iaik.tc.tss.impl.csp.TcCrypto;
import iaik.tc.tss.impl.java.tcs.TcTcsCommon;
import iaik.tc.tss.impl.java.tcs.pbg.TcTpmCmdCapability;
import iaik.tc.tss.impl.java.tcs.pbg.TcTpmCmdDeprKey;
import iaik.tc.tss.impl.java.tcs.pbg.TcTpmCmdEviction;
import iaik.tc.tss.impl.java.tddl.TcTddl;
import iaik.tc.utils.logging.Log;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.SortedMap;
import java.util.TreeMap;

public class TcTcsKeyHandleMgr {

	/**
	 * This class is implemented as a singleton. This field holds then only instance of the class.
	 */
	protected static TcTcsKeyHandleMgr instance_ = null;

	/**
	 * This field holds the TCS keyHandles currently in use.
	 */
	protected LinkedList keyHandles_ = new LinkedList();

	/**
	 * mapping: TCS key handle -> TPM key handle
	 */
	protected SortedMap khTcsToTpm_ = new TreeMap();

	/**
	 * mapping: TPM key handle -> TCS key handle
	 * 
	 * This reverse mapping is required when swapping out keys from the TPM. In such a case, the
	 * corresponding TCS key handles have to be looked up.
	 */
	protected SortedMap khTpmToTcs_ = new TreeMap();

	/**
	 * mapping: 'last usage' timestamp (in ms) -> TPM key handle
	 * 
	 * This map is used to keep track when a TPM key has been used for the last time. Whenever a key
	 * has to be evicted from the TMP, the key that has not been used for the longest time is
	 * selected.
	 * 
	 * An entry is added to the map whenever a key is loaded into the TPM (i.e. when a TCS to TPM key
	 * handle mapping is established). An entry is removed whenever a key is evicted from the TPM
	 * (i.e. the TCS to TPM key handle mapping is removed). Updates of the 'last usage' timestamp are
	 * triggered via the {@link TcTcsKeyHandleMgr#updateTpmKhUsage(long)}.
	 */
	protected SortedMap khTpmUsageTimeStamps_ = new TreeMap();


	/*************************************************************************************************
	 * Making constructor unavailable (Singleton).
	 */
	private TcTcsKeyHandleMgr() throws TcTddlException, TcTpmException
	{
		// add pre-defined key handles to list of used TCS key handles
		synchronized (keyHandles_) {
			keyHandles_.add(new Long(TcTpmConstants.TPM_KH_ADMIN));
			keyHandles_.add(new Long(TcTpmConstants.TPM_KH_EK));
			keyHandles_.add(new Long(TcTpmConstants.TPM_KH_OPERATOR));
			keyHandles_.add(new Long(TcTpmConstants.TPM_KH_OWNER));
			keyHandles_.add(new Long(TcTpmConstants.TPM_KH_REVOKE));
			keyHandles_.add(new Long(TcTpmConstants.TPM_KH_SRK));
			keyHandles_.add(new Long(TcTpmConstants.TPM_KH_TRANSPORT));
		}

		// Evict all currently loaded keys on startup.
		// Rationale: They are not known to/controlled by the TSS and therefore can
		// not be managed by the TSS.
		TcTddl dest = TcTddl.getInstance();
		Object[] tpmOutData = TcTpmCmdCapability.TpmGetCapability(dest,
				TcTpmConstants.TPM_CAP_KEY_HANDLE, null);

		
		TcTpmKeyHandleList khList = new TcTpmKeyHandleList((TcBlobData) tpmOutData[1]);

		if (TcTcsCommon.isOrdinalSupported(TcTpmOrdinals.TPM_ORD_FlushSpecific)) {
			// TPM 1.2 style
			for (int i = 0; i < khList.getLoaded(); i++) {
				try {
					TcTpmCmdEviction.TpmFlushSpecific(dest, khList.getHandle()[i], TcTpmConstants.TPM_RT_KEY);
				} catch(TcTssException e) {
					Log.info("Unable to flush key handle (0x" + Long.toHexString(khList.getHandle()[i]) + "). TPM Emulator bug?");
				}
			}
		} else {
			// TPM 1.1 style
			for (int i = 0; i < khList.getLoaded(); i++) {
				TcTpmCmdDeprKey.TpmEvictKey(dest, khList.getHandle()[i]);
			}
		}
	}


	/*************************************************************************************************
	 * This class can only be instantiated once (Singleton).
	 */
	public static synchronized TcTcsKeyHandleMgr getInstance() throws TcTddlException, TcTpmException
	{
		if (instance_ == null) {
			instance_ = new TcTcsKeyHandleMgr();
		}

		return instance_;
	}


	/*************************************************************************************************
	 * This method returns the next available (free) TCS key handle. The key handles generated by this
	 * method are randomized.
	 */
	protected long getNextFreeTcsKeyHandle()
	{
		Long newHandle = null;
		synchronized (keyHandles_) {
			do {
				TcBlobData raw = TcCrypto.getRandom(4);
				long handle = new TcBasicTypeDecoder(raw).decodeUINT32();
				newHandle = new Long(handle);
			} while (keyHandles_.contains(newHandle));

			keyHandles_.add(newHandle);
		}
		return newHandle.longValue();
	}


	/*************************************************************************************************
	 * This method frees (invalidates) the given key handle.
	 * 
	 * @param keyHandle
	 */
	protected void freeKeyHandle(long keyHandle)
	{
		if (keyHandle == TcTpmConstants.TPM_KH_ADMIN || keyHandle == TcTpmConstants.TPM_KH_EK
				|| keyHandle == TcTpmConstants.TPM_KH_OPERATOR || keyHandle == TcTpmConstants.TPM_KH_OWNER
				|| keyHandle == TcTpmConstants.TPM_KH_REVOKE || keyHandle == TcTpmConstants.TPM_KH_SRK
				|| keyHandle == TcTpmConstants.TPM_KH_TRANSPORT) {
			return;
		}

		synchronized (keyHandles_) {
			keyHandles_.remove(new Long(keyHandle));
		}
	}


	/**
	 * This method is used to update the 'last usage' timestamp of a TPM key handle. It is called
	 * whenever a key is used (via the {@link TcTcsKeyCache#ensureKeyIsLoadedInTpm(long)} method).
	 */
	protected void updateTpmKhUsage(long khTcs)
	{
		synchronized (khTpmUsageTimeStamps_) {
			Iterator it = khTpmUsageTimeStamps_.keySet().iterator();
			while (it.hasNext()) {
				if (((Long) khTpmUsageTimeStamps_.get((Long) it.next())).equals(new Long(khTcs))) {
					it.remove();
					khTpmUsageTimeStamps_.put(new Long(System.currentTimeMillis()), new Long(khTcs));
					break;
				}
			}
		}
	}


	/**
	 * This method returns the TPM key handle that has not been used for the longest time (LRU - least
	 * recently used).
	 */
	protected long getTpmKhLruNotParent(long khTpmParent) throws TcTcsException
	{
		synchronized (khTpmUsageTimeStamps_) {
			if (khTpmUsageTimeStamps_.size() < 1) {
				throw new TcTcsException(TcTcsErrors.TCS_E_INTERNAL_ERROR,
						"Unable to determine LRU key handle");
			}

			Iterator it = khTpmUsageTimeStamps_.keySet().iterator();
			Long kh = (Long) khTpmUsageTimeStamps_.get((Long) it.next());

			// if first ky is the parent key return the second LRU key
			if (kh.longValue() == khTpmParent) {
				if (khTpmUsageTimeStamps_.size() < 2) {
					throw new TcTcsException(TcTcsErrors.TCS_E_INTERNAL_ERROR,
							"Unable to determine LRU key handle");
				}
				kh = (Long) khTpmUsageTimeStamps_.get((Long) it.next());
			}

			// Iterator itDbg = khTpmUsageTimeStamps_.keySet().iterator();
			// while (itDbg.hasNext()) {
			// Long time = (Long)itDbg.next();
			// Long val = (Long)khTpmUsageTimeStamps_.get(time);
			// Log.debug(time + " -> " + val);
			// }
			// Log.debug("removing kh " + kh);

			return kh.longValue();
		}
	}


	/*************************************************************************************************
	 * This method adds a new (bidirectional) TCS to TPM key handle mapping.
	 * 
	 * @param khTpm The TPM key handle.
	 * @param khTcs The TCS key handle.
	 */
	protected void addKeyHandleMapping(long khTpm, long khTcs)
	{
		synchronized (khTcsToTpm_) {
			synchronized (khTpmToTcs_) {
				synchronized (khTpmUsageTimeStamps_) {
					khTcsToTpm_.put(new Long(khTcs), new Long(khTpm));
					khTpmToTcs_.put(new Long(khTpm), new Long(khTcs));
					khTpmUsageTimeStamps_.put(new Long(System.currentTimeMillis()), new Long(khTpm));
				}
			}
		}
	}


	/*************************************************************************************************
	 * This method removes a TCS to TPM key handle mapping based on the given TCS key handle.
	 * 
	 * @param khTcs TCS key handle to be removed.
	 * 
	 * @throws TcTcsException This exception is thrown if the given key handle could not be found.
	 */
	protected void removeKeyHandleMappingByTcsKh(long khTcs) throws TcTcsException
	{
		synchronized (khTcsToTpm_) {
			synchronized (khTpmToTcs_) {
				synchronized (khTpmUsageTimeStamps_) {
					if (khTcsToTpm_.containsKey(new Long(khTcs))) {
						Long khTpm = (Long) khTcsToTpm_.remove(new Long(khTcs));
						khTpmToTcs_.remove(khTpm);

						// Note: A typical TPM has ~20 key slots. Therefore it is acceptable
						// to iterate over the key handles.
						Iterator it = khTpmUsageTimeStamps_.keySet().iterator();
						while (it.hasNext()) {
							Long keyHandle = (Long) khTpmUsageTimeStamps_.get((Long) it.next());
							if (keyHandle.equals(khTpm)) {
								it.remove();
								break;
							}
						}

					} else {
						throw new TcTcsException(TcTcsErrors.TCS_E_INVALID_KEYHANDLE,
								"No key with this TCS key handle found (handle: " + khTcs + ").");
					}
				}
			}
		}
	}


	/*************************************************************************************************
	 * This method returns the TPM key handle for the given TCS key handle. If no matching TCS key
	 * handle was found, and exception is thrown.
	 * 
	 * @param khTcs TCS key handle to find the TPM key handle for.
	 * @return The TPM key handle corresponding to the given TCS key handle.
	 * 
	 * @throws TcTcsException This exception is thrown if no key with the given TCS key handle could
	 *           be found.
	 */
	public long getTpmKhForTcsKh(long khTcs) throws TcTcsException
	{
		synchronized (khTcsToTpm_) {
			synchronized (khTpmToTcs_) {
				if (!khTcsToTpm_.containsKey(new Long(khTcs))) {
					throw new TcTcsException(TcTcsErrors.TCS_E_INVALID_KEYHANDLE,
							"No key with this TCS key handle found (handle: " + khTcs + ").");
				} else {
					Long khTpm = ((Long) khTcsToTpm_.get(new Long(khTcs)));
					return khTpm.longValue();
				}
			}
		}
	}


	/**
	 * This method returns the TCS key handle for the given TPM key handle. If no matching TPM key
	 * handle was found, and exception is thrown.
	 * 
	 * @param khTpm TPM key handle to find the TCS key handle for.
	 * @return The TCS key handle corresponding to the given TPM key handle.
	 * 
	 * @throws TcTcsException This exception is thrown if no key with the given TPM key handle could
	 *           be found.
	 */
	public long getTcsKhForTpmKh(long khTpm) throws TcTcsException
	{
		synchronized (khTcsToTpm_) {
			synchronized (khTpmToTcs_) {
				if (!khTpmToTcs_.containsKey(new Long(khTpm))) {
					throw new TcTcsException(TcTcsErrors.TCS_E_INVALID_KEYHANDLE,
							"No key with this TPM key handle found (handle: " + khTpm + ").");
				} else {
					Long khTcs = ((Long) khTpmToTcs_.get(new Long(khTpm)));
					return khTcs.longValue();
				}
			}
		}
	}
}
